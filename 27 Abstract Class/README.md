# 27 Abstract Class

# 추상 클래스

```java
public abstract class MyAbstractClass {
	String str;
	int num;
	
	// constructor
	public MyAbstractClass() {}
	public MyAbstractClass(String str, int num) {
		this.str = str;
		this.num = num;
	}
	
	// abstract method
	public **abstract** void printInfo();
	
}
```

`Access abstract class ClassName() {}`

추상 클래스는 추상 메서드를 가질 수 있다.

반드시 추상 메서드를 가지지는 않는다.

→ 추상 클래스가 아닌 클래스는 추상 메서드를 가질 수 없다.

> ### Concreate Class
> 
> 
> 일반 클래스.
> 
> 추상 메서드를 가지지 않는다.
> 

## 추상 메서드

`Access abstract ReturnDatatype methodName();`

상세 기능부는 정의되지 않은 메서드(signiture만 가짐, 중괄호 생략, 실행문 없음).

`**abstract`키워드는 생략할 수 없다.**

**반드시 자식 클래스에서 해당 메서드를 오버 라이딩 해야한다.**

→ 해당 추상 클래스를 상속받은 클래스들은 동일한 명의 메서드를 가짐을 보장한다.

- 그냥 하나의 함수를 오버라이딩하면 안되나?
    
    → 하지만 모든 자식 클래스들이 해당 메서드를 적당하게 사용한다고 보장 불가
    
    ex) `toString()` : 반드시 객체의 값을 출력한다고 보장 안 됨.
    
- 어떤 기능을 하는 함수를 자식 클래스들이 모두 다른 메서드를 정의해 사용할 수 있음
    
    → 관리의 어려움
    

## 추상 클래스와 객체

추상 클래스로는 객체 생성이 불가하다.

1. 인스턴스화하기 위해서는 해당 클래스를 상속받은 자식 클래스 타입으로 선언한다.
2. **추상 메서드는 반드시 오버라이딩**해야 한다.
    
    기능 구현이 되어 있지 않기 때문이다.
    
    → **자식 클래스에서 부모 클래스의 추상 메서드 오버라이딩하지 않을 시 컴파일 에러**
    
3. 객체 생성은 불가하지만 데이터 타입으로는 사용할 수 있다.
    
    → 다형성 사용 가능(자식 클래스 타입을 추상 클래스 타입으로 업캐스팅 가능)
    
    → 파라미터의 데이터 타입으로 사용 가능
    
    → 리턴 데이터 타입으로 사용 가능
    
    → [제너릭](https://gangnam-americano.tistory.com/47)의 요소로 사용 가능
    
4. 생성자는 가질 수 있다.
    
    추상 클래스를 상속한 자식 클래스에서 호출할 수 있다.
    

## 추상 클래스의 장점

상속의 일반적인 성격은 모두 가진다.

→ 상속의 모든 규칙을 따른다.

어떠한 메서드는 반드시 오버라이딩하도록 강제한다

→ 보다 **논리적인 구조 정의**에 용이

→ 슈퍼 클래스 추상화

→ 서브 클래스 메서드 통일